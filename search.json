[{"path":"/2023/04/24/Spring5/","content":"Spring51.、Spring1.1、简介 Spring ——&gt; 春天，为开源软件带来了春天 2002，首次推出了Spring框架的雏形：interface21框架！ Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版 Spring的理念：使用现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！ SSH：Struct2 + Spring + Hibernate（全自动持久化框架）！ SSM：SpringMVC + Spring + MyBatis（半自动持久化框架，可自定义性质更强）！ spring官网： https://spring.io/projects/spring-framework#overview 官方下载： https://repo.spring.io/release/org/springframework/spring/ GitHub： https://github.com/spring-projects/spring-framework Spring Web MVC： spring-webmvc最新版 Spring Web MVC和Spring-JDBC的pom配置文件： 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 1.2 优点 Spring是一个开源的免费的框架（容器）！ Spring是一个轻量级的、非入侵式的框架！ 控制反转（IoC），面向切面编程（AOP） 支持事务的处理，对框架整合的支持！（几乎市面上所有热门框架都能整合进去）！ === 总结一句话：Spring就是一个轻量级的控制反转（IoC）和面向切面编程（AOP）的框架！ === 1.3 组成 1.4、扩展现代化的java开发 -&gt; 基于Spring的开发！ Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速开发单个微服务 约定大于配置！ Spring Cloud SpringCloud是基于SpringBoot实现的！ 因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！ 2、IoC（控制反转）理论推导传统的调用 UserDao 1234package dao;public interface UserDao &#123;\tvoid getUser();&#125; UserDaoImp 123456package dao;public class UserDaoImpl implements UserDao&#123;\tpublic void getUser() &#123; System.out.println(&quot;默认获取用户数据&quot;); &#125;&#125; UserSevice 1234package Service;public interface UserService &#123;\tvoid getUser();&#125; UserServiceImp 12345678910package Service;import dao.UserDao;import dao.UserDaoImpl;public class UserServiceImpl implements UserService&#123; UserDao userDao = new UserDaoImpl(); public void getUser()&#123; userDao.getUser(); &#125;\t&#125; 测试 1234567891011package holle0;import Service.UserService;import Service.UserServiceImpl;public class MyTest0 &#123;\tpublic static void main(String[] args) &#123; // 用户实际调用的是业务层，dao层他们不需要接触 UserService userService = new UserServiceImpl(); userService.getUser();\t&#125;&#125; 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！ 改良：我们使用一个Set接口实现。已经发生了革命性的变化！ 12345678//在Service层的实现类(UserServiceImpl)增加一个Set()方法//利用set动态实现值的注入！//DAO层并不写死固定调用哪一个UserDao的实现类//而是通过Service层调用方法设置实现类！private UserDao userDao;public void setUserDao(UserDao userDao)&#123; this.userDao = userDao;&#125; set() 方法实际上是动态改变了 UserDao userDao 的 初始化部分（**new UserDaoImpl()**） 测试中加上 1((UserServiceImpl)userService).setUserDao(new UserDaoImpl()); 之前，程序是主动创建对象！控制权在程序猿手上！ 使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！（主动权在客户手上） 本质上解决了问题，程序员不用再去管理对象的创建 系统的耦合性大大降低，可以更专注在业务的实现上 这是IoC（控制反转）的原型，反转(理解)：主动权交给了用户 IoC本质 3、HolleSpring在父模块中导入jar包 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt;\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;\t&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\t&lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; pojo的Hello.java 12345678910111213141516171819package pojo;public class Hello &#123;\tprivate String str; public String getStr() &#123; return str;\t&#125;\tpublic void setStr(String str) &#123; this.str = str;\t&#125; @Override\tpublic String toString() &#123; return &quot;Holle [str=&quot; + str + &quot;]&quot;;\t&#125;&#125; 在resource里面的xml配置 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--在Spring中创建对象，在Spring这些都称为bean 类型 变量名 = new 类型(); Holle holle = new Holle(); bean = 对象(holle) id = 变量名(holle) class = new的对象(new Holle();) property 相当于给对象中的属性设值,让str=&quot;Spring&quot; --&gt; &lt;bean id=&quot;hello&quot; class=&quot;pojo.Hello&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类MyTest 123456789101112131415161718package holle1;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.Hello;public class MyTest &#123;\tpublic static void main(String[] args) &#123; //获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //我们的对象下能在都在spring·中管理了，我们要使用，直接取出来就可以了 Hello holle = (Hello) context.getBean(&quot;hello&quot;); System.out.println(holle.toString());\t&#125;&#125; 核心用set注入，所以必须要有下面的se()方法 1234//Hello类public void setStr(String str) &#123; this.str = str;\t&#125; 思考： IoC：对象由Spring 来创建，管理，装配！ 弹幕评论里面的理解： 原来这套程序是：你写好菜单买好菜，客人来了自己把菜炒好招待，就相当于你请人吃饭现在这套程序是：你告诉楼下餐厅，你要哪些菜，客人来的时候，餐厅把做好的你需要的菜送上来IoC：炒菜这件事，不再由你自己来做，而是委托给了第三方__餐厅来做 此时的区别就是，如果我还需要做其他的菜，我不需要自己搞菜谱买材料再做好，而是告诉餐厅，我要什么菜，什么时候要，你做好送来 . 在前面第一个module试试引入Spring 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userDaomSql&quot; class=&quot;dao.UserDaoMysqlImpl&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userServiceImpl&quot; class=&quot;service.UserServiceImp&quot;&gt; &lt;!--ref引用spring中已经创建很好的对象--&gt; &lt;!--value是一个具体的值,基本数据类型--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaomSql&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第一个module改良后测试 123456789101112package holle0;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import service.UserServiceImpl;public class MyTest0 &#123;\tpublic static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(&quot;userServiceImpl&quot;); userServiceImpl.getUser();\t&#125;&#125; 总结： 所有的类都要装配的beans.xml 里面； 所有的bean 都要通过容器去取； 容器里面取得的bean，拿出来就是一个对象，用对象调用方法即可； 4、IoC创建对象的方式 使用无参构造创建对象，默认。 使用有参构造（如下） 下标赋值 index指的是有参构造中参数的下标，下标从0开始; 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;chen&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 类型赋值（不建议使用） 123&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kuang&quot;/&gt;&lt;/bean&gt; 直接通过参数名（掌握） 1234&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;kuang&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- 比如参数名是name，则有name=&quot;具体值&quot; --&gt; 注册bean之后就对象的初始化了（**类似 new 类名()**） 弹幕评论： name方式还需要无参构造和set方法,index和type只需要有参构造 就算是new 两个对象，也是只有一个实例（单例模式：全局唯一） 123User user = (User) context.getBean(&quot;user&quot;);User user2 = (User) context.getBean(&quot;user&quot;);system.out.println(user == user2)//结果为true 总结：在配置文件加载的时候，容器(&lt; bean&gt;)中管理的对象就已经初始化了 5、Spring配置5.1、别名12345678&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;chen&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;alias name=&quot;user&quot; alias=&quot;userLove&quot;/&gt;&lt;!-- 使用时\tUser user2 = (User) context.getBean(&quot;userLove&quot;);\t--&gt; 5.2、Bean的配置123456789&lt;!--id：bean的唯一标识符，也就是相当于我们学的对象名class：bean对象所对应的会限定名：包名+类型name：也是别名，而且name可以同时取多个别名 --&gt;&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; name=&quot;u1 u2,u3;u4&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;chen&quot;/&gt;&lt;/bean&gt;&lt;!-- 使用时\tUser user2 = (User) context.getBean(&quot;u1&quot;);\t--&gt; 5.3、importimport一般用于团队开发使用，它可以将多个配置文件，导入合并为一个 假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！ 张三(beans.xm1) 李四(beans2.xm1) 王五(beans3.xm1) applicationContext.xml 123&lt;import resource=&quot;beans.xm1&quot;/&gt;&lt;import resource=&quot;beans2.xml&quot;/&gt;&lt;import resource=&quot;beans3.xm1&quot;/&gt; 使用的时候，直接使用总的配置就可以了 弹幕评论： 按照在总的xml中的导入顺序来进行创建，后导入的会重写先导入的，最终实例化的对象会是后导入xml中的那个 6、依赖注入（DI）6.1、构造器注入第4点有提到 6.2、set方式注入【重点】依赖注入：set注入！ 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 【环境搭建】 复杂类型 Address类 真实测试对象 Student类 beans.xml 测试 MyTest3 Student类 123456789101112131415161718192021222324252627282930313233package pojo;import java.util.*;@Get@Setpublic class Student &#123;//别忘了写get和set方法（用lombok注解也行） private String name; private Address address; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String, String&gt; card; private Set&lt;String&gt; game; private Properties infor; private String wife; @Override public String toString() &#123; return &quot;Student&#123;&quot; +&quot; &quot;+ &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +&quot; &quot;+ &quot;, address=&quot; + address.toString() +&quot; &quot;+ &quot;, books=&quot; + Arrays.toString(books) +&quot; &quot;+ &quot;, hobbies=&quot; + hobbies +&quot; &quot;+ &quot;, card=&quot; + card +&quot; &quot;+ &quot;, game=&quot; + game +&quot; &quot;+ &quot;, infor=&quot; + infor +&quot; &quot;+ &quot;, wife=&#x27;&quot; + wife + &#x27;\\&#x27;&#x27; +&quot; &quot;+ &#x27;&#125;&#x27;; &#125;&#125; Address类 123456789101112131415161718192021package pojo;public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return &quot;Address&#123;&quot; + &quot;address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; beans.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\txmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\t&lt;bean id=&quot;address&quot; class=&quot;pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;address你好&quot; /&gt;\t&lt;/bean&gt;\t&lt;bean id=&quot;student&quot; class=&quot;pojo.Student&quot;&gt; &lt;!--第一种，普通值注入 --&gt; &lt;property name=&quot;name&quot; value=&quot;name你好&quot; /&gt; &lt;!--第二种，ref注入 --&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot; /&gt; &lt;!--数组注入 --&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;三国&lt;/value&gt; &lt;value&gt;西游&lt;/value&gt; &lt;value&gt;水浒&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list列表注入 --&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;rap&lt;/value&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map键值对注入 --&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;entry key=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set(可去重)注入 --&gt; &lt;property name=&quot;game&quot;&gt; &lt;set&gt; &lt;value&gt;wangzhe&lt;/value&gt; &lt;value&gt;lol&lt;/value&gt; &lt;value&gt;galname&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--空指针null注入 --&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; &lt;!--properties常量注入 --&gt; &lt;property name=&quot;infor&quot;&gt; &lt;props&gt; &lt;prop key=&quot;id&quot;&gt;20200802&lt;/prop&gt; &lt;prop key=&quot;name&quot;&gt;cbh&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;\t&lt;/bean&gt;&lt;/beans&gt; MyTest3 1234567891011import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.Student;public class MyTest3 &#123;\tpublic static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student stu = (Student) context.getBean(&quot;student&quot;); System.out.println(stu.toString());\t&#125;\t&#125; 6.3、拓展注入官方文档位置 pojo增加User类 123456789101112131415161718192021222324252627282930package pojo;public class User &#123; private String name; private int id;\tpublic User() &#123; &#125;\tpublic User(String name, int id) &#123; super(); this.name = name; this.id = id;\t&#125;\tpublic String getName() &#123; return name;\t&#125;\tpublic void setName(String name) &#123; this.name = name;\t&#125;\tpublic int getId() &#123; return id;\t&#125;\tpublic void setId(int id) &#123; this.id = id;\t&#125;\t@Override\tpublic String toString() &#123; return &quot;User [name=&quot; + name + &quot;, id=&quot; + id + &quot;]&quot;;\t&#125;&#125; 注意： beans 里面加上这下面两行 使用p和c命名空间需要导入xml约束 xmlns:p=“http://www.springframework.org/schema/p”xmlns:c=“http://www.springframework.org/schema/c” 123456789101112131415?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--p命名空间注入/set注入，可以直接注入属性的值-》property--&gt; &lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; p:name=&quot;cxk&quot; p:id=&quot;20&quot; &gt; &lt;/bean&gt; &lt;!--c命名空间，通过构造器注入，需要写入有参和无参构造方法-》construct-args--&gt; &lt;bean id=&quot;user2&quot; class=&quot;pojo.User&quot; c:name=&quot;cbh&quot; c:id=&quot;22&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 测试 123ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);User user = context.getBean(&quot;user&quot;,User.class);//确定class对象，就不用再强转了System.out.println(user.toString()); 6.4、Bean作用域 单例模式（默认） 12&lt;bean id=&quot;user2&quot; class=&quot;pojo.User&quot; c:name=&quot;cxk&quot; c:age=&quot;19&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;1 弹幕评论：单例模式是把对象放在pool中，需要再取出来，使用的都是同一个对象实例 原型模式: 每次从容器中get的时候，都产生一个新对象！ 12&lt;bean id=&quot;user2&quot; class=&quot;pojo.User&quot; c:name=&quot;cxk&quot; c:age=&quot;19&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;1 其余的request、session、application这些只能在web开放中使用！ 7、Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文自动寻找，并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显示配置 在java中显示配置 隐式的自动装配bean 【重要】 环境搭建：一个人有两个宠物 byType自动装配：byType会自动查找，和自己对象set方法参数的类型相同的bean 保证所有的class唯一(类为全局唯一) byName自动装配：byName会自动查找，和自己对象set对应的值对应的id 保证所有id唯一，并且和set注入的值一致 1234&lt;!-- 找不到id和多个相同class --&gt;&lt;bean id=&quot;cat1&quot; class=&quot;pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;pojo.Cat&quot;/&gt;&lt;!-- 找不到 id=cat，且有两个Cat --&gt; 7.1测试：自动装配pojo的Cat类 12345public class Cat &#123; public void shut()&#123; System.out.println(&quot;miao&quot;); &#125;&#125; pojo的Dog类 1234567public class Dog &#123; public void shut()&#123; System.out.println(&quot;wow&quot;); &#125;&#125; pojo的People类 123456789101112131415161718192021222324252627282930313233343536373839package pojo;public class People &#123; private Cat cat; private Dog dog; private String name; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;People&#123;&quot; + &quot;cat=&quot; + cat + &quot;, dog=&quot; + dog + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; xml配置 -&gt; byType 自动装配 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;cat&quot; class=&quot;pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog&quot; class=&quot;pojo.Dog&quot;/&gt; &lt;!--byType会在容器自动查找，和自己对象属性相同的bean 例如，Dog dog; 那么就会查找pojo的Dog类，再进行自动装配\t--&gt; &lt;bean id=&quot;people&quot; class=&quot;pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;cbh&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; xml配置 -&gt; byName 自动装配 123456789&lt;bean id=&quot;cat&quot; class=&quot;pojo.Cat&quot;/&gt;&lt;bean id=&quot;dog&quot; class=&quot;pojo.Dog&quot;/&gt;&lt;!--byname会在容器自动查找，和自己对象set方法的set后面的值对应的id 例如:setDog()，取set后面的字符作为id，则要id = dog 才可以进行自动装配 --&gt;&lt;bean id=&quot;people&quot; class=&quot;pojo.People&quot; autowire=&quot;byName&quot;&gt;\t&lt;property name=&quot;name&quot; value=&quot;cbh&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 弹幕评论：byName只能取到小写，大写取不到 7.2、使用注解实现自动装配jdk1.5支持的注解，spring2.5支持的注解 The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.（翻译：基于注释的配置的引入提出了一个问题，即这种方法是否比XML“更好”） 导入context约束 xmlns:context=”http://www.springframework.org/schema/context&quot; 配置注解的支持：&lt; context:annotation-config/&gt; 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 7.2.1、@Autowired默认是byType方式，如果匹配不上，就会byName 在属性上个使用，也可以在set上使用 我们可以不用编写set方法了，前提是自动装配的属性在Spring容器里，且要符合ByName 自动装配 1234567public class People &#123; @Autowired private Cat cat; @Autowired private Dog dog; private String name;&#125; @Nullable 字段标记了这个注解，说明该字段可以为空 public name(@Nullable String name){ } 1234//源码public @interface Autowired &#123; boolean required() default true; &#125; 如果定义了Autowire的require属性为false，说明这个对象可以为null，否则不允许为空（false表示找不到装配，不抛出异常） 7.2.2、@Autowired+@Qualifier@Autowired不能唯一装配时，需要@Autowired+@Qualifier 如果@Autowired自动装配环境比较复杂。自动装配无法通过一个注解完成的时候，可以使用@Qualifier(value = “dog”)去配合使用，指定一个唯一的id对象 12345678public class People &#123; @Autowired private Cat cat; @Autowired @Qualifier(value = &quot;dog&quot;) private Dog dog; private String name;&#125; 弹幕评论： 如果xml文件中同一个对象被多个bean使用，Autowired无法按类型找到，可以用@Qualifier指定id查找 7.2.3、@Resource默认是byName方式，如果匹配不上，就会byType 1234567public class People &#123; Resource(name=&quot;cat&quot;) private Cat cat; Resource(name=&quot;dog&quot;) private Dog dog; private String name;&#125; 弹幕评论： Autowired是byType，@Autowired+@Qualifier = byType || byName Autowired是先byteType,如果唯一則注入，否则byName查找。resource是先byname,不符合再继续byType 区别：@Resource和@Autowired的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】 @Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】 执行顺序不同：@Autowired通过byType的方式实现。@Resource默认通过byname的方式实现 8、使用注解开发在spring4之后，使用注解开发，必须要保证aop包的导入使用注解需要导入contex的约束 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 8.1、bean弹幕评论：有了&lt; context:component-scan&gt;，另一个&lt; context:annotation-config/&gt;标签可以移除掉，因为已经被包含进去了。 1234&lt;!--指定要扫描的包，这个包下面的注解才会生效\t别只扫一个com.kuang.pojo包--&gt; &lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt; &lt;context:annotation-config/&gt; 123456//@Component 组件//等价于&lt;bean id=&quot;user&quot; classs&quot;pojo.User&quot;/&gt; @Componentpublic class User &#123; public String name =&quot;秦疆&quot;;&#125; 8.2、属性如何注入@value123456789101112@Componentpublic class User &#123; //相当于&lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt; @value(&quot;kuangshen&quot;) public String name; //也可以放在set方法上面 //@value(&quot;kuangshen&quot;) public void setName(String name) &#123; this.name = name; &#125;&#125; 8.3、衍生的注解@Component有几个衍生注解，会按照web开发中，mvc架构中分层。 dao （@Repository） service（@Service） controller（@Controller） 这四个注解的功能是一样的，都是代表将某个类注册到容器中 8.4、自动装配置@Autowired：默认是byType方式，如果匹配不上，就会byName @Nullable：字段标记了这个注解，说明该字段可以为空 @Resource：默认是byName方式，如果匹配不上，就会byType 8.5、作用域@scope12345678910111213141516//原型模式prototype，单例模式singleton//scope(&quot;prototype&quot;)相当于&lt;bean scope=&quot;prototype&quot;&gt;&lt;/bean&gt;@Component @scope(&quot;prototype&quot;)public class User &#123; //相当于&lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt; @value(&quot;kuangshen&quot;) public String name; //也可以放在set方法上面 @value(&quot;kuangshen&quot;) public void setName(String name) &#123; this.name = name; &#125;&#125; 8.6、小结xml与注解： xml更加万能，维护简单，适用于任何场合 注解，不是自己的类使用不了，维护复杂 最佳实践： xml用来管理bean 注解只用来完成属性的注入 要开启注解支持 9、使用Java的方式配置Spring不使用Spring的xml配置，完全交给java来做！ Spring的一个子项目，在spring4之后，，，它成为了核心功能 实体类：pojo的User.java 1234567891011121314151617181920//这里这个注解的意思,就是说明这个类被Spring接管了,注册到了容器中 @component public class User &#123; private String name; public String getName() &#123; return name; &#125; //属性注入值 @value(&quot;QINJIANG&#x27;) public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;user&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27;+ &#x27;&#125;&#x27;; &#125; &#125; 弹幕评论：要么使用@Bean，要么使用@Component和ComponentScan，两种效果一样 配置文件：config中的kuang.java @Import(KuangConfig2.class)，用@import来包含KuangConfig2.java 123456789101112131415//这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于&lt;beans&gt;标签@Configuration @componentScan(&quot;com.Kuang.pojo&quot;) //开启扫描//@Import(KuangConfig2.class)public class KuangConfig &#123; //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -&gt;getUser //这个方法的返同值,就相当于bean 标签中的class 属性 -&gt;User //@Bean public User getUser()&#123; return new User(); //就是返回要注入到bean的对象! &#125; &#125; 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 12345678public class MyTest &#123; public static void main(String[ ] args) &#123; //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( &quot;getUser&quot;); //方法名getUser System.out.Println(getUser.getName()); &#125; &#125; 会创建两个相同对象问题的说明： 弹幕总结 - -&gt; @Bean是相当于&lt; bean&gt;标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 123456789101112131415//这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于&lt;beans&gt;标签@Configuration @componentScan(&quot;com.Kuang.pojo&quot;) //开启扫描//@Import(KuangConfig2.class)public class KuangConfig &#123; //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -&gt;getUser //这个方法的返同值,就相当于bean 标签中的class 属性 -&gt;User //@Bean public User getUser()&#123; return new User(); //就是返回要注入到bean的对象! &#125; &#125; 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 12345678public class MyTest &#123; public static void main(String[ ] args) &#123; //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( &quot;getUser&quot;); //方法名getUser System.out.Println(getUser.getName()); &#125; &#125; 会创建两个相同对象问题的说明： 弹幕总结 - -&gt; @Bean是相当于&lt; bean&gt;标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 10、动态代理代理模式是SpringAOP的底层 分类：动态代理和静态代理 10.1、静态代理代码步骤： 1、接口 1234package pojo;public interface Host &#123;\tpublic void rent();&#125; 2、真实角色 1234567package pojo;public class HostMaster implements Host&#123; public void rent() &#123; System.out.println(&quot;房东要出租房子&quot;);\t&#125;&#125; 3、代理角色 123456789101112131415161718192021222324252627282930313233package pojo;public class Proxy &#123;\tpublic Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; super(); this.host = host;\t&#125; public void rent() &#123; seeHouse(); host.rent(); fee(); sign();\t&#125;\t//看房\tpublic void seeHouse() &#123; System.out.println(&quot;看房子&quot;);\t&#125;\t//收费\tpublic void fee() &#123; System.out.println(&quot;收中介费&quot;);\t&#125;\t//合同\tpublic void sign() &#123; System.out.println(&quot;签合同&quot;);\t&#125; &#125; 4、客户端访问代理角色 123456789101112131415161718package holle4_proxy;import pojo.Host;import pojo.HostMaster;import pojo.Proxy;public class My &#123;\tpublic static void main(String[] args) &#123; //房东要出租房子 Host host = new HostMaster(); //中介帮房东出租房子，但也收取一定费用（增加一些房东不做的操作） Proxy proxy = new Proxy(host); //看不到房东，但通过代理，还是租到了房子 proxy.rent(); &#125;&#125; 代码翻倍：几十个真实角色就得写几十个代理 AOP横向开发 10.2、动态代理动态代理和静态角色一样，动态代理底层是反射机制 动态代理类是动态生成的，不是我们直接写好的！ 动态代理(两大类)：基于接口，基于类 基于接口：JDK的动态代理【使用ing】 基于类：cglib java字节码实现：javasisit 了解两个类1、Proxy：代理2、InvocationHandler：调用处理程序 实例： 接口 Host.java 123456//接口package pojo2;public interface Host &#123;\tpublic void rent();\t&#125; 接口Host实现类 HostMaster.java 1234567//接口实现类package pojo2;public class HostMaster implements Host&#123; public void rent() &#123; System.out.println(&quot;房东要租房子&quot;);\t&#125;&#125; 代理角色的处理程序类 ProxyInvocationHandler.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package pojo2;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;///用这个类，自动生成代理public class ProxyInvocationHandler implements InvocationHandler &#123;\t// Foo f =(Foo) Proxy.NewProxyInstance(Foo. Class.GetClassLoader(),\t// new Class&lt;?&gt;[] &#123; Foo.Class &#125;,\t// handler);\t// 被代理的接口\tpublic HostMaster hostMaster ; public void setHostMaster(HostMaster hostMaster) &#123; this.hostMaster = hostMaster;\t&#125;\t// 得到生成的代理类 public Object getProxy() &#123; // newProxyInstance() -&gt; 生成代理对象，就不用再写具体的代理类了 // this.getClass().getClassLoader() -&gt; 找到加载类的位置 // hostMaster.getClass().getInterfaces() -&gt; 代理的具体接口 // this -&gt; 代表了接口InvocationHandler的实现类ProxyInvocationHandler return Proxy.newProxyInstance(this.getClass().getClassLoader(), hostMaster.getClass().getInterfaces(), this);\t// 处理代理实例并返回结果\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; seeHouse(); // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(hostMaster, args); fee(); return result;\t&#125;\tpublic void seeHouse() &#123; System.out.println(&quot;看房子&quot;);\t&#125;\tpublic void fee() &#123; System.out.println(&quot;收中介费&quot;);\t&#125;&#125; 用户类 My2.java 123456789101112131415161718192021222324252627package holle4_proxy;import pojo2.Host;import pojo2.Host2;import pojo2.HostMaster;import pojo2.ProxyInvocationHandler;public class My2 &#123;\tpublic static void main(String[] args) &#123; //真实角色 HostMaster hostMaster = new HostMaster(); //代理角色，现在没有；用代理角色的处理程序来实现Host接口的调用 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //pih -&gt; HostMaster接口类 -&gt; Host接口 pih.setHostMaster(hostMaster); //获取newProxyInstance动态生成代理类 Host proxy = (Host) pih.getProxy(); proxy.rent();\t&#125;&#125; 弹幕评论：什么时候调用invoke方法的?代理实例调用方法时invoke方法就会被调用，可以debug试试 改为万能代理类 123456789101112131415161718192021222324///用这个类，自动生代理public class ProxyInvocationHandler implements InvocationHandler &#123;\t// 被代理的接口\tpublic Object target;\tpublic void setTarget(Object target) &#123; this.target = target;\t&#125;\t// 得到生成的代理类 -&gt; 固定的代码\tpublic Object getProxy() &#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);\t&#125;\t// 处理代理实例并返回结果\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(target, args); return result;\t&#125;&#125; 11、AOP11.1、什么是AOP 11.2、AOP在Spring中的使用提供声明式事务，允许用户自定义切面 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等… 切面(Aspect)：横切关注点 被模块化的特殊对象。即，它是一个类。（Log类） 通知(Advice)：切面必须要完成的工作。即，它是类中的一个方法。（Log类中的方法） 目标(Target)：被通知对象。（生成的代理类) 代理(Proxy)：向目标对象应用通知之后创建的对象。（生成的代理类） 切入点(PointCut)：切面通知执行的”地点”的定义。（最后两点：在哪个地方执行，比如：method.invoke()） 连接点(JointPoint)：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即AOP在不改变原有代码的情况下，去增加新的功能。（代理） 11.3、使用Spring实现AOP导入jar包 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 11.3.1、方法一：使用原生spring接口springAPI接口实现 applicationContext.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;userservice&quot; class=&quot;service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;log.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;log.AfterLog&quot;/&gt;\t&lt;!--方式一，使用原生Spring API接口--&gt; &lt;!--配置aop,还需要导入aop约束--&gt; &lt;aop:config&gt; &lt;!--切入点：expression:表达式，execution（要执行的位置）--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--UserServiceImpl.*(..) -》 UserServiceImpl类下的所以方法(参数)--&gt; &lt;!--执行环绕增加--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;!-- 环绕,在id=&quot;pointcut&quot;的前后切入 --&gt; &lt;/aop:config&gt;&lt;/beans&gt; execution(返回类型，类名，方法名(参数)) -&gt; execution(* com.service.,(…)) UserService.java 1234567package service;public interface UserService &#123; public void add() ; public void delete() ; public void query() ; public void update();&#125; UserService 的实现类 UserServiceImp.java 1234567891011121314151617package service;public class UserServiceImpl implements UserService &#123; public void add() &#123; System.out.println(&quot;add增&quot;); &#125; public void delete() &#123; System.out.println(&quot;delete删&quot;); &#125; public void update() &#123; System.out.println(&quot;update改&quot;); &#125; public void query() &#123; System.out.println(&quot;query查&quot;); &#125;&#125; 前置Log.java 123456789101112package log;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class Log implements MethodBeforeAdvice &#123; //method：要执行的目标对象的方法 //args：参数 //target：目标对象 public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;被执行了&quot;); &#125;&#125; 后置AfterLog.java 12345678910package log;import java.lang.reflect.Method;import org.springframework.aop.AfterReturningAdvice;public class AfterLog implements AfterReturningAdvice &#123; //returnVaule: 返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;执行了&quot;+method.getName()+&quot;方法，返回值是&quot;+returnValue); &#125;&#125; 测试类MyTest5 123456789101112import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import service.UserService;public class MyTest5 &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //注意:动态代理代理的是接口 UserService userService = (UserService) context.getBean(&quot;userservice&quot;); userService.add(); &#125;&#125; 11.3.2、方法二：自定义类实现AOP1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;userservice&quot; class=&quot;service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;log.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;log.AfterLog&quot;/&gt; &lt;!-- 方式二，自定义 --&gt; &lt;bean id=&quot;diy&quot; class=&quot;diy.DiyPointcut&quot;/&gt; &lt;aop:config&gt; &lt;!--自定义切面--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* service.UserServiceImpl.*(..))&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 1234567891011package diy;public class DiyPointcut &#123; public void before()&#123; System.out.println(&quot;插入到前面&quot;); &#125; public void after()&#123; System.out.println(&quot;插入到后面&quot;); &#125;&#125; 123456789//测试public class MyTest5 &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //注意:动态代理代理的是接口 UserService userService = (UserService) context.getBean(&quot;userservice&quot;); userService.add(); &#125;&#125; 11.3.3、方法三：使用注解实现1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 注册 --&gt; &lt;bean id=&quot;userservice&quot; class=&quot;service.UserServiceImpl&quot;/&gt; &lt;!--方式三，使用注解实现--&gt; &lt;bean id=&quot;diyAnnotation&quot; class=&quot;diy.DiyAnnotation&quot;&gt;&lt;/bean&gt; &lt;!-- 开启自动代理 实现方式：默认JDK (proxy-targer-class=&quot;fasle&quot;) cgbin (proxy-targer-class=&quot;true&quot;)--&gt;\t&lt;aop:aspectj-autoproxy/&gt; &lt;/beans&gt; DiyAnnotation.java 123456789101112131415161718192021222324252627282930package diy;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspect //标注这个类是一个切面public class DiyAnnotation &#123; @Before(&quot;execution(* service.UserServiceImpl.*(..))&quot;) public void before()&#123; System.out.println(&quot;=====方法执行前=====&quot;); &#125; @After(&quot;execution(* service.UserServiceImpl.*(..))&quot;) public void after()&#123; System.out.println(&quot;=====方法执行后=====&quot;); &#125; //在环绕增强中，我们可以给地暖管一个参数，代表我们要获取切入的点 @Around(&quot;execution(* service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); Object proceed = joinPoint.proceed(); System.out.println(&quot;环绕后&quot;); &#125;&#125; 测试 12345678public class MyTest5 &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //注意:动态代理代理的是接口 UserService userService = (UserService) context.getBean(&quot;userservice&quot;); userService.add(); &#125;&#125; 输出结果： 12、整合mybatismybatis-spring官网：https://mybatis.org/spring/zh/ mybatis的配置流程： 编写实体类 编写核心配置文件 编写接口 编写Mapper.xmi 测试 12.1、mybatis-spring-方式一 编写数据源配置 sqISessionFactory sqISessionTemplate（相当于sqISession） 需要给接口加实现类【new】 将自己写的实现类，注入到Spring中 测试！ 先导入jar包 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;\t&lt;!--在build中配置resources，来防止资源导出失败的问题--&gt;&lt;!-- Maven解决静态资源过滤问题 --&gt;&lt;build&gt;&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt;&lt;/build&gt; 编写顺序：User -&gt; UserMapper -&gt; UserMapper.xml -&gt; spring-dao.xml -&gt; UserServiceImpl -&gt; applicationContext.xml -&gt; MyTest6 代码步骤： pojo实体类 User 12345678package pojo;import lombok.Data;@Datapublic class User &#123;\tprivate int id;\tprivate String name;\tprivate String pwd;&#125; mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper 123456package mapper;import java.util.List;import pojo.User;public interface UserMapper &#123;\tpublic List&lt;User&gt; getUser();&#125; UserMapperImpl 12345678910111213141516171819package mapper;import java.util.List;import org.mybatis.spring.SqlSessionTemplate;import pojo.User;public class UserMapperImpl implements UserMapper&#123; //我们的所有操作，在原来都使用sqlSession来执行，现在都使用SqlSessionTemplate；\tprivate SqlSessionTemplate sqlSessionTemplate;\tpublic void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) &#123; this.sqlSessionTemplate = sqlSessionTemplate;\t&#125;\tpublic List&lt;User&gt; getUser() &#123; UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class); return mapper.getUser();\t&#125;&#125; UserMapper.xml （狂神给面子才留下来的） 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- 绑定接口 --&gt;&lt;mapper namespace=&quot;mapper.UserMapper&quot;&gt;\t&lt;select id=&quot;getUser&quot; resultType=&quot;pojo.User&quot;&gt; select * from mybatis.mybatis\t&lt;/select&gt;&lt;/mapper&gt; resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;\t&lt;!--开启日志--&gt;\t&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;\t&lt;/settings&gt; &lt;!--可以给实体类起别名 --&gt;\t&lt;typeAliases&gt; &lt;package name=&quot;pojo&quot; /&gt;\t&lt;/typeAliases&gt;&lt;/configuration&gt; spring-dao.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\txmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\txsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--DataSource:使用Spring的数帮源替换Mybatis的配置 其他数据源：c3p0、dbcp、druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --&gt;\t&lt;!--data source --&gt;\t&lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;\t&lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot; /&gt; &lt;!--绑定 mybatis 配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;/bean&gt;\t&lt;!-- sqlSessionTemplate 就是之前使用的：sqlsession --&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!-- 只能使用构造器注入sqlSessionFactory 原因：它没有set方法--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; applicationContext.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\txmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\txsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 导入spring-dao.xml --&gt;\t&lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;bean id=&quot;userMapper&quot; class=&quot;mapper.UserMapperImpl&quot;&gt; &lt;property name=&quot;sqlSessionTemplate&quot; ref=&quot;sqlSession&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 12345678910111213141516import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import mapper.UserMapper;import pojo.User;public class MyTest6 &#123;\tpublic static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper&quot;); for (User user : userMapper.getUser()) &#123; System.out.println(user); &#125;\t&#125;&#125; 12.2、mybatis-spring-方式二UserServiceImpl2 1234567891011121314package mapper;import pojo.User;import org.apache.ibatis.session.SqlSession;import org.mybatis.spring.support.SqlSessionDaoSupport;import java.util.List;//继承SqlSessionDaoSupport 类public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper &#123; public List&lt;User&gt; getUser() &#123; SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者一句话：return getSqlSession().getMapper(UserMapper.class).getUser(); &#125;&#125; spring-dao.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\txmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\txsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--DataSource:使用Spring的数帮源替换Mybatis的配置 c3p0 dbcp druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --&gt;\t&lt;!--data source --&gt;\t&lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;\t&lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot; /&gt; &lt;!--绑定 mybatis 配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 方法二：SqlSessionTemplate 可以不写了--&gt; &lt;/beans&gt; applicationContext.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\txmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\txsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\t&lt;import resource=&quot;spring-dao.xml&quot; /&gt;\t&lt;!-- 方法二 --&gt;\t&lt;bean id=&quot;userMapper2&quot; class=&quot;mapper.UserMapperImpl2&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;\t&lt;/bean&gt;&lt;/beans&gt; 测试 123456789public class MyTest6 &#123;\tpublic static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper2&quot;); for (User user : userMapper.getUser()) &#123; System.out.println(user); &#125;\t&#125;&#125; 13. 声明式事务 把一组业务当成一个业务来做；要么都成功，要么都失败！ 事务在项目开发中，十分的重要，涉及到数据的一致性问题 确保完整性和一致性 事务的ACID原则：1、原子性2、隔离性3、一致性4、持久性 ACID参考文章：https://www.cnblogs.com/malaikuangren/archive/2012/04/06/2434760.html Spring中的事务管理 声明式事务：AOP 编程式事务：需要再代码中，进行事务管理 声明式事务 先导入jar包 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;\t&lt;!--在build中配置resources，来防止资源导出失败的问题--&gt;&lt;!-- Maven解决静态资源过滤问题 --&gt;&lt;build&gt;&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt;&lt;/build&gt; 代码步骤： pojo实体类 User 12345678910111213package pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;\tprivate int id;\tprivate String name;\tprivate String pwd;&#125; mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper 123456789101112package mapper;import java.util.List;import org.apache.ibatis.annotations.Param;import pojo.User;public interface UserMapper &#123;\tpublic List&lt;User&gt; getUser(); public int insertUser(User user); public int delUser(@Param(&quot;id&quot;) int id); &#125; UserMapperImpl 1234567891011121314151617181920212223242526package mapper;import pojo.User;import org.apache.ibatis.session.SqlSession;import org.mybatis.spring.support.SqlSessionDaoSupport;import java.util.List;public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper &#123; public List&lt;User&gt; getUser() &#123; User user = new User(5,&quot;你好&quot;,&quot;ok&quot;); insertUser(user); delUser(5); SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者return getSqlSession().getMapper(UserMapper.class).getUser(); &#125; //插入\tpublic int insertUser(User user) &#123; return getSqlSession().getMapper(UserMapper.class).insertUser(user);\t&#125;\t//删除\tpublic int delUser(int id) &#123; return getSqlSession().getMapper(UserMapper.class).delUser(id);\t&#125;&#125; UserMapper.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- 绑定接口 --&gt;&lt;mapper namespace=&quot;mapper.UserMapper&quot;&gt;\t&lt;select id=&quot;getUser&quot; resultType=&quot;pojo.User&quot;&gt; select * from mybatis.mybatis\t&lt;/select&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;pojo.User&quot; &gt; insert into mybatis.mybatis (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)\t&lt;/insert&gt; &lt;delete id=&quot;delUser&quot; parameterType=&quot;_int&quot;&gt; deleteAAAAA from mybatis.mybatis where id = #&#123;id&#125; &lt;!-- deleteAAAAA是故意写错的 --&gt;\t&lt;/delete&gt;&lt;/mapper&gt; resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!-- configuration --&gt;&lt;configuration&gt; &lt;!--开启日志--&gt;\t&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;\t&lt;/settings&gt; &lt;!--可以给实体类起别名--&gt;\t&lt;typeAliases&gt; &lt;package name=&quot;pojo&quot; /&gt;\t&lt;/typeAliases&gt;&lt;/configuration&gt; spring-dao.xml（已导入约束） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--data source --&gt;\t&lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;\t&lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot; /&gt; &lt;!--绑定 mybatis 配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!--声明式事务--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;constructor-arg ref=&quot;datasource&quot; /&gt; &lt;/bean&gt; &lt;!--结合aop实现事务织入--&gt; &lt;!--配置事务的通知类--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!--给哪些方法配置事务--&gt; &lt;!--新东西：配置事务的传播特性 propagation--&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;query&quot; read-only=&quot;true&quot;/&gt; &lt;!-- *号包含上面4个方法： &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; --&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置事务切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;txpointcut&quot; expression=&quot;execution(* mapper.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txpointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; applicationContext.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\txmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\txsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\t&lt;import resource=&quot;spring-dao.xml&quot; /&gt;\t&lt;bean id=&quot;userMapper&quot; class=&quot;mapper.UserMapperImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;\t&lt;/bean&gt;&lt;/beans&gt; 测试类 12345678910111213141516import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import mapper.UserMapper;import pojo.User;public class MyTest7 &#123;\tpublic static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper&quot;); for (User user : userMapper.getUser()) &#123; System.out.println(user); &#125;\t&#125;&#125; 思考：为什么需要事务？ 如果不配置事务，可能存在数据提交不一致的情况下； 如果不在spring中去配置声明式事务，我们就需要在代码中手动配置事务！ 事务在项目的开发中非常重要，涉及到数据的一致性和完整性问题！"},{"path":"/2023/04/24/Mybatis/","content":"简介MyBatis 分享自写源码和笔记，希望对大家有帮助 本人配置 jdk13.0.2 （jdk1.7以上均可） Maven 3.6.3 MySQL 5.7.23 （mysql5.6以上均可） 1. 配置官网文档： https://mybatis.org/mybatis-3/zh/getting-started.html pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;batis&lt;/groupId&gt; &lt;artifactId&gt;batis-maven&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;mybatis-01&lt;/module&gt; &lt;/modules&gt; &lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; src/main/resources12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://111.230.212.103:3306/mybatis?userSSL=true&amp;amp; userUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;hdk123&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; src/main/java123456789101112131415161718192021222324252627282930313233package com.hou.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;//sqlSessionFactory --&gt; sqlSessionpublic class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; //使用mybatis第一步：获取sqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 // 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句 public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 编写代码 实体类 src/main/java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.hou.pogo;public class User &#123; private int id; private String name; private String pwd; public User() &#123; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; Dao接口 123456789package com.hou.dao;import com.hou.pogo.User;import java.util.List;public interface UserDao &#123; List&lt;User&gt; getUserList();&#125; 接口实现类 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace绑定一个对应的mapper接口--&gt;&lt;mapper namespace=&quot;com.hou.dao.UserDao&quot;&gt; &lt;!--id方法名--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.hou.pogo.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 测试注意点： org.apache.ibatis.binding.BindingException: Type interface com.hou.dao.UserDao is not known to the MapperRegistry. mybatis-config.xml12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://111.230.212.103:3306/mybatis?userSSL=true&amp;amp; userUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;hdk123&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--每一个mapper.xml都需要注册--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/hou/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 在两个pom.xml中加入 1234567891011121314151617181920&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 步骤 导入包 配置数据库 建造工具类 SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。 SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式 2. 增删改查1. namespacenamespace中的包名要和接口一致 2. select id：就是对应的namespace的方法名 resultType：sql语句的返回值！ parameterType： 参数类型！ 编写接口 编写对应的mapper中的对应语句 测试 UserMapper1234567891011121314151617181920212223package com.hou.dao;import com.hou.pogo.User;import java.util.List;public interface UserMapper &#123; //查询全部用户 List&lt;User&gt; getUserList(); //根据id查询用户 User getUserById(int id); //插入用户 void addUser(User user); //修改用户 int updateUser(User user); //删除用户 int deleteUser(int id);&#125; UserMapper.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace绑定一个对应的mapper接口--&gt;&lt;mapper namespace=&quot;com.hou.dao.UserMapper&quot;&gt; &lt;!--id方法名--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.hou.pogo.User&quot;&gt; select * from mybatis.user &lt;/select&gt; &lt;select id=&quot;getUserById&quot; resultType=&quot;com.hou.pogo.User&quot; parameterType=&quot;int&quot;&gt; select * from mybatis.user where id = #&#123;id&#125; &lt;/select&gt; &lt;!--对象中的属性可以直接取出来--&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.hou.pogo.User&quot;&gt; insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;); &lt;/insert&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.hou.pogo.User&quot;&gt; update mybatis.user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id =#&#123;id&#125;; &lt;/update&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id=#&#123;id&#125;; &lt;/delete&gt;&lt;/mapper&gt; Test12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.hou.dao;import com.hou.pogo.User;import com.hou.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class UserDaoTest &#123; @Test public void test()&#123; // 获得sqlsession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); try&#123; // 1.执行 getmapper UserMapper userDao = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = userDao.getUserList(); // method 2// List&lt;User&gt; userList = sqlSession.selectList(&quot;com.hou.dao.UserDao.getUserList&quot;); for(User user: userList)&#123; System.out.println(user); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; //关闭 sqlSession.close(); &#125; &#125; @Test public void getUserById()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); &#125; //增删改需要提交事务 @Test public void addUser()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.addUser(new User(5,&quot;hou&quot;,&quot;123456&quot;)); //提交事务 sqlSession.commit(); sqlSession.close(); &#125; @Test public void updateUser()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.updateUser(new User(4,&quot;hou&quot;,&quot;123&quot;)); //提交事务 sqlSession.commit(); sqlSession.close(); &#125; @Test public void deleteUser()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.deleteUser(5); //提交事务 sqlSession.commit(); sqlSession.close(); &#125;&#125; 注意点：增删改需要提交事务。 3. Map假如我们的实体类属性过多，用map，传递map的key 123&lt;insert id=&quot;addUser2&quot; parameterType=&quot;map&quot;&gt; insert into mybatis.user (id, name, pwd) values (#&#123;id1&#125;, #&#123;name1&#125;, #&#123;pwd1&#125;);&lt;/insert&gt; 1int addUser2(Map&lt;String, Object&gt; map); 123456789101112131415@Testpublic void addUser2()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;id1&quot;,5); map.put(&quot;name1&quot;,&quot;dong&quot;); map.put(&quot;pwd1&quot;,&quot;12345&quot;); mapper.addUser2(map); //提交事务 sqlSession.commit(); sqlSession.close();&#125; 4.模糊查询java代码执行的时候，传递通配符% 123&lt;select id=&quot;getUserLike&quot; resultType=&quot;com.hou.pogo.User&quot;&gt; select * from mybatis.user where name like #&#123;value&#125;&lt;/select&gt; 12345678910111213@Testpublic void getUserLike()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = mapper.getUserLike(&quot;%o%&quot;); for(User user : list)&#123; System.out.println(user); &#125; sqlSession.close();&#125; 3. 配置解析1. 核心配置文件 mybatis-config.xml 12345678910111213configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） ###2. 环境配置（environments） MyBatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 Mybatis 默认的事务管理器是JDBC，连接池：POOLED 3. 属性我们可以通过properties属性来引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。 （db.properties） 编写一个配置文件 db.properties 1234driver = com.mysql.jdbc.Driverurl = &quot;jdbc:mysql://111.230.212.103:3306/mybatis?userSSL=true&amp;userUnicode=true&amp;characterEncoding=UTF-8&quot;username = root password = hdk123 在核心配置文件中引入 mybatis-config.xml (同时有的话，优先走外面properties) 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--引入外部配置文件--&gt; &lt;!--&lt;properties resource=&quot;db.properties&quot;/&gt;--&gt; &lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;hdk123&quot;&gt;&lt;/property&gt; &lt;/properties&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--每一个mapper.xml都需要注册--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/hou/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4. 类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字。 123&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.hou.pogo.User&quot; alias=&quot;User&quot;&gt;&lt;/typeAlias&gt;&lt;/typeAliases&gt; 扫描实体类的包，默认别名就为这个类的类名首字母小写 123&lt;typeAliases&gt; &lt;package name=&quot;com.hou.pogo&quot;&gt;&lt;/package&gt;&lt;/typeAliases&gt; 在实体类，比较少的时候使用第一种，实体类多使用第二种。 第一种可以自定义，第二则不行，但是 若有注解，则别名为其注解值 。 123@Alias(&quot;hello&quot;)public class User &#123;&#125; 5. 设置 设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 true | false false logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 6. 其他 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） mybatis-generator-core mybatis-plus 通用mapper 7. 映射器方式一: [推荐使用] 123&lt;mappers&gt; &lt;mapper resource=&quot;com/hou/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 方式二： 123&lt;mappers&gt; &lt;mapper class=&quot;com.hou.dao.UserMapper&quot; /&gt;&lt;/mappers&gt; 接口和它的Mapper必须同名 接口和他的Mapper必须在同一包下 方式三： 12345&lt;mappers&gt; &lt;!--&lt;mapper resource=&quot;com/hou/dao/UserMapper.xml&quot;/&gt;--&gt; &lt;!--&lt;mapper class=&quot;com.hou.dao.UserMapper&quot; /&gt;--&gt; &lt;package name=&quot;com.hou.dao&quot; /&gt;&lt;/mappers&gt; 接口和它的Mapper必须同名 接口和他的Mapper必须在同一包下 8.生命周期和作用域作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder: 一旦创建了 SqlSessionFactory，就不再需要它了 。 局部变量 SqlSessionFactory： 就是数据库连接池。 一旦被创建就应该在应用的运行期间一直存在 ，没有任何理由丢弃它或重新创建另一个实例 。 多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。 因此 SqlSessionFactory 的最佳作用域是应用作用域。 最简单的就是使用单例模式或者静态单例模式。 SqlSession： 每个线程都应该有它自己的 SqlSession 实例。 连接到连接池的请求！ SqlSession 的实例不是线程安全的，因此是不能被共享的 ，所以它的最佳的作用域是请求或方法作用域。 用完之后赶紧关闭，否则资源被占用。 4. 解决属性名和字段名不一致的问题数据库中的字段 新建一个项目，拷贝之前，测试实体字段不一致的情况 User 12345678package com.hou.pogo;public class User &#123; private int id; private String name; private String password;&#125; 问题： User{id=2, name=’wang’, password=’null’} 解决方法： 核心配置文件 起别名 1234&lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot; parameterType=&quot;int&quot;&gt; select id,name,pwd as password from mybatis.user where id = #&#123;id&#125;&lt;/select&gt; resultMap 结果集映射 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace绑定一个对应的mapper接口--&gt;&lt;mapper namespace=&quot;com.hou.dao.UserMapper&quot;&gt; &lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot; parameterType=&quot;int&quot;&gt; select * from mybatis.user where id = #&#123;id&#125; &lt;/select&gt; &lt;!--结果集映射--&gt; &lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--colunm 数据库中的字段，property实体中的属性--&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt;&lt;/mapper&gt; resultMap 元素是 MyBatis 中最重要最强大的元素。 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 123456&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--colunm 数据库中的字段，property实体中的属性--&gt; &lt;!--&lt;result column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/result&gt;--&gt; &lt;!--&lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;--&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt; 5. 日志1. 日志工厂如果一个数据库操作出现了异常，我们需要排错。日志就是最好的助手。 曾经：sout，debug 现在：日志工厂 logImpl SLF4J LOG4J [掌握] LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING [掌握] NO_LOGGING 具体使用哪一个，在设置中设定 STDOUT_LOGGING 标志日志输出 mybatis-confi中 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; 2. Log4j 先导包 pom.xml下 12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 新建log4j.properties文件 123456789101112131415161718192021222324### set log levels ###log4j.rootLogger = DEBUG,console,file### 输出到控制台 ###log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold = DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern = [%c]-%m%n### 输出到日志文件 ###log4j.appender.file=org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/hou.loglog4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n# 日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 配置实现 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt; Log4j使用 1234567891011121314151617181920212223242526272829303132333435363738package com.hou.dao;import com.hou.pojo.User;import com.hou.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.apache.log4j.Logger;import org.junit.Test;public class UserDaoTest &#123; static Logger logger = Logger.getLogger(UserDaoTest.class); @Test public void test()&#123; // 获得sqlsession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); try&#123; // 1.执行 getmapper UserMapper userDao = sqlSession.getMapper(UserMapper.class); logger.info(&quot;测试&quot;); User user = userDao.getUserById(2); System.out.println(user); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; //关闭 sqlSession.close(); &#125; &#125; @Test public void testLog4j()&#123; logger.info(&quot;info:进入了testlog4j&quot;); logger.debug(&quot;debug:进入了testlog4j&quot;); logger.error(&quot;error:进入了testlog4j&quot;); &#125;&#125; 6. 分页1. Limit 分页语法： 12SELECT * from user limit startIndex,pageSize;SELECT * from user limit 0,2; 12345678910111213141516package com.hou.dao;import com.hou.pojo.User;import java.util.List;import java.util.Map;public interface UserMapper &#123; //根据id查询用户 User getUserById(int id); List&lt;User&gt; getUserByLimit(Map&lt;String, Integer&gt; map);&#125; xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace绑定一个对应的mapper接口--&gt;&lt;mapper namespace=&quot;com.hou.dao.UserMapper&quot;&gt; &lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot; parameterType=&quot;int&quot;&gt; select * from mybatis.user where id = #&#123;id&#125; &lt;/select&gt; &lt;!--结果集映射--&gt; &lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--colunm 数据库中的字段，property实体中的属性--&gt; &lt;!--&lt;result column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/result&gt;--&gt; &lt;!--&lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;--&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultType=&quot;User&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125; &lt;/select&gt;&lt;/mapper&gt; test类 123456789101112131415@Testpublic void getByLimit()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(&quot;startIndex&quot;, 1); map.put(&quot;pageSize&quot;, 2); List&lt;User&gt; userList = mapper.getUserByLimit(map); for(User user:userList)&#123; System.out.println(user); &#125; sqlSession.close();&#125; 2. RowBounds分页@Test 1234567891011121314151617@Testpublic void getUserByRow()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); //RowBounds实现 RowBounds rowBounds = new RowBounds(1, 2); //通过java代码层面 List&lt;User&gt; userList = sqlSession.selectList (&quot;com.hou.dao.UserMapper.getUserByRowBounds&quot;, null,rowBounds); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close();&#125; 3. 分页插件 pageHelper 7. 使用注解开发 删除 UserMapper.xml UserMapper 123456789101112package com.hou.dao;import com.hou.pojo.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface UserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; getUsers();&#125; 核心配置 mybatis-config.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--引入外部配置文件--&gt; &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;!--可以给实体类起别名--&gt; &lt;typeAliases&gt; &lt;typeAlias type=&quot;com.hou.pojo.User&quot; alias=&quot;User&quot;&gt;&lt;/typeAlias&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--绑定接口--&gt; &lt;mappers&gt; &lt;mapper class=&quot;com.hou.dao.UserMapper&quot;&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 本质：反射机制 底层：动态代理！ Mybatis详细执行流程： Resource获取全局配置文件 实例化SqlsessionFactoryBuilder 解析配置文件流XMLCondigBuilder Configration所有的配置信息 SqlSessionFactory实例化 trasactional事务管理 创建executor执行器 创建SqlSession 实现CRUD 查看是否执行成功 提交事务 关闭 注解CRUD12345678910111213141516171819202122232425262728package com.hou.dao;import com.hou.pojo.User;import org.apache.ibatis.annotations.*;import java.util.List;public interface UserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; getUsers(); //方法存在多个参数，所有的参数必须加@Param @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User getUserById(@Param(&quot;id&quot;) int id); @Insert(&quot;insert into user (id, name, pwd) values&quot; + &quot;(#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;) int addUser(User user); @Update(&quot;update user set name=#&#123;name&#125;, pwd=#&#123;password&#125; &quot; + &quot;where id=#&#123;id&#125;&quot;) int updateUser(User user); @Delete(&quot;delete from user where id=#&#123;id&#125;&quot;) int deleteUser(@Param(&quot;id&quot;) int id);&#125; MybatisUtile 12345678910111213141516171819202122232425262728293031package com.hou.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;//sqlSessionFactory --&gt; sqlSessionpublic class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; //使用mybatis第一步：获取sqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(true); &#125;&#125; Test 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.hou.dao;import com.hou.pojo.User;import com.hou.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class UserDaoTest &#123; @Test public void test()&#123; // 获得sqlsession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); try&#123; // 1.执行 getmapper UserMapper userDao = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = userDao.getUsers(); for (User user : userList) &#123; System.out.println(user); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; //关闭 sqlSession.close(); &#125; &#125; @Test public void getuserById()&#123; // 获得sqlsession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); try&#123; // 1.执行 getmapper UserMapper userDao = sqlSession.getMapper(UserMapper.class); User user = userDao.getUserById(1); System.out.println(user); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; //关闭 sqlSession.close(); &#125; &#125; @Test public void addUser()&#123; // 获得sqlsession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); try&#123; // 1.执行 getmapper UserMapper userDao = sqlSession.getMapper(UserMapper.class); userDao.addUser(new User(6, &quot;kun&quot;,&quot;123&quot;)); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; //关闭 sqlSession.close(); &#125; &#125; @Test public void updateUser()&#123; // 获得sqlsession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); try&#123; // 1.执行 getmapper UserMapper userDao = sqlSession.getMapper(UserMapper.class); userDao.updateUser(new User(6, &quot;fang&quot;,&quot;123&quot;)); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; //关闭 sqlSession.close(); &#125; &#125; @Test public void deleteUser()&#123; // 获得sqlsession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); try&#123; // 1.执行 getmapper UserMapper userDao = sqlSession.getMapper(UserMapper.class); userDao.deleteUser(6); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; //关闭 sqlSession.close(); &#125; &#125;&#125; 8. Lombok 在IDEA中安装lombok插件 配置 12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ```@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows 12345678910111213141516171819202122@Data: 无参构造，get，set，toString，hashCode在实体类上加注解```javapackage com.hou.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private int id; private String name; private String password;&#125; 9. 多对一处理 多个学生关联一个老师（多对一） 集合（一对多） 1. 建表123456789101112131415161718192021CREATE TABLE `teacher` (\t`id` INT(10) NOT NULL PRIMARY KEY,\t`name` VARCHAR(30) DEFAULT NULL)ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher (`id`, `name`) VALUES (1, &#x27;hou&#x27;);CREATE TABLE `student` (\t`id` INT(10) NOT NULL,\t`name` VARCHAR(30) DEFAULT NULL,\t`tid` INT(10) DEFAULT NULL,\tPRIMARY KEY (`id`),\tKEY `fktid` (`tid`),\tCONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`))ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO student (`id`, `name`, `tid`) VALUES (1, &#x27;xiao1&#x27;, 1);INSERT INTO student (`id`, `name`, `tid`) VALUES (2, &#x27;xiao2&#x27;, 1);INSERT INTO student (`id`, `name`, `tid`) VALUES (3, &#x27;xiao3&#x27;, 1);INSERT INTO student (`id`, `name`, `tid`) VALUES (4, &#x27;xiao4&#x27;, 1);INSERT INTO student (`id`, `name`, `tid`) VALUES (5, &#x27;xiao5&#x27;, 1); 新建实体类 123456789101112package com.hou.pojo;import lombok.Data;@Datapublic class Student &#123; private int id; private String name; //学生需要关联一个老师 private Teacher teacher;&#125; 123456789package com.hou.pojo;import lombok.Data;@Datapublic class Teacher &#123; private int id; private String name;&#125; 建立Mapper接口 建立Mapper.xml 测试是否能够成功 2. 按照查询嵌套处理StudentMapper.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.hou.dao.StudentMapper&quot;&gt; &lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student; &lt;/select&gt; &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;com.hou.pojo.Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/result&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt; &lt;!--对象使用assiociation--&gt; &lt;!--集合用collection--&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;com.hou.pojo.Teacher&quot; select=&quot;getTeacher&quot;&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;getTeacher&quot; resultType=&quot;com.hou.pojo.Teacher&quot;&gt; select * from teacher where id = #&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt; 3. 按照结果嵌套处理12select s.id sid,s.name sname,t.name tnamefrom student s,teacher t where s.tid=t.id; 12345678910111213&lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;com.hou.pojo.Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;&gt;&lt;/result&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;&gt;&lt;/result&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;com.hou.pojo.Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt; property 映射到列结果的字段或属性。 column 数据库中的列名，或者是列的别名。 10. 一对多一个老师拥有多个学生 对于老师而言就是一对多 1.环境搭建实体类 1234567891011package com.hou.pojo;import lombok.Data;import java.util.List;@Datapublic class Teacher &#123; private int id; private String name; private List&lt;Student&gt; studentList;&#125; 12345678910package com.hou.pojo;import lombok.Data;@Datapublic class Student &#123; private int id; private String name; private int tid;&#125; 2. 按照结果查询123456789101112131415&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt; select s.id sid, s.name sname, t.name tname, t.id tid from student s, teacher t where s.tid = t.id and t.id = #&#123;id&#125;;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;com.hou.pojo.Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;&gt;&lt;/result&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;&gt;&lt;/result&gt; &lt;!--集合中的泛型信息，我们用oftype获取--&gt; &lt;collection property=&quot;studentList&quot; ofType=&quot;com.hou.pojo.Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;&gt;&lt;/result&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt; 3. 按照查询嵌套处理12345678910111213&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt; select * from mybatis.teacher where id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;com.hou.pojo.Teacher&quot;&gt; &lt;collection property=&quot;studentList&quot; column=&quot;id&quot; javaType=&quot;ArrayList&quot; ofType=&quot;com.hou.pojo.Student&quot; select=&quot;getStudentByTeacherId&quot;&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;com.hou.pojo.Student&quot;&gt; select * from mybatis.student where tid = #&#123;id&#125;&lt;/select&gt; 小结 关联 - association 多对一 集合 - collection 一对多 javaType &amp; ofType JavaType用来指定实体中属性类型 ofType映射到list中的类型，泛型中的约束类型 注意点： 保证sql可读性，尽量保证通俗易懂 注意字段问题 如果问题不好排查错误，使用日志 11. 动态sql动态sql：根据不同的条件生成不同的SQL语句 1. 搭建环境1234567create table `blog`(\t`id` varchar(50) not null comment &#x27;博客id&#x27;, `title` varchar(100) not null comment &#x27;博客标题&#x27;, `author` varchar(30) not null comment &#x27;博客作者&#x27;, `create_time` datetime not null comment &#x27;创建时间&#x27;, `views` int(30) not null comment &#x27;浏览量&#x27;\t)ENGINE=InnoDB DEFAULT CHARSET=utf8 实体类 1234567891011121314package com.hou.pojo;import lombok.Data;import java.util.Date;@Datapublic class Blog &#123; private String id; private String title; private String author; private Date createTime; private int views;&#125; 核心配置 123&lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; Mapper.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.hou.mapper.BlogMapper&quot;&gt; &lt;insert id=&quot;addBlog&quot; parameterType=&quot;Blog&quot;&gt; insert into mybatis.blog (id, title, author, create_time, views) values (#&#123;id&#125;, #&#123;title&#125;, #&#123;author&#125;, #&#123;create_time&#125;, #&#123;views&#125;); &lt;/insert&gt;&lt;/mapper&gt; 新建随机生成ID包 12345678910111213141516171819package com.hou.utils;import org.junit.Test;import java.util.UUID;@SuppressWarnings(&quot;all&quot;)public class IDUtiles &#123; public static String getId()&#123; return UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); &#125; @Test public void test()&#123; System.out.println(getId()); &#125;&#125; 测试类：添加数据 12345678910111213141516171819202122232425262728293031323334353637383940import com.hou.mapper.BlogMapper;import com.hou.pojo.Blog;import com.hou.utils.IDUtiles;import com.hou.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.Date;public class MyTest &#123; @Test public void addBlog()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper blogMapper = sqlSession.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IDUtiles.getId()); blog.setAuthor(&quot;houdongun&quot;); blog.setCreateTime(new Date()); blog.setViews(999); blog.setTitle(&quot;first&quot;); blogMapper.addBlog(blog); blog.setId(IDUtiles.getId()); blog.setTitle(&quot;second&quot;); blogMapper.addBlog(blog); blog.setId(IDUtiles.getId()); blog.setTitle(&quot;third&quot;); blogMapper.addBlog(blog); blog.setId(IDUtiles.getId()); blog.setTitle(&quot;forth&quot;); blogMapper.addBlog(blog); sqlSession.close(); &#125;&#125; 2. if123456789&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;Blog&quot;&gt; select * from mybatis.blog where 1=1 &lt;if test=&quot;title != null&quot;&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != author&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/select&gt; test 1234567891011121314151617@Testpublic void queryBlogIF()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper blogMapper = sqlSession.getMapper(BlogMapper.class); Map map = new HashMap(); // map.put(&quot;title&quot;, &quot;second&quot;); map.put(&quot;author&quot;, &quot;houdongun&quot;); List&lt;Blog&gt; list = blogMapper.queryBlogIF(map); for (Blog blog : list) &#123; System.out.println(blog); &#125; sqlSession.close();&#125; 3. choose、when、otherwise12345678910111213141516&lt;select id=&quot;queryBlogchoose&quot; parameterType=&quot;map&quot; resultType=&quot;Blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views = #&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 4. trim、where、set123456789101112&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt; update mybatis.blog &lt;set&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; author = #&#123;author&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;&lt;/update&gt; trim 可以自定义 SQL片段有些时候我们有一些公共部分 使用sql便签抽取公共部分 在使用的地方使用include标签 123456789101112131415&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/sql&gt;&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;Blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;/where&gt;&lt;/select&gt; 注意： 最好基于单表 sql里不要存在where标签 5. for-each12345678910&lt;!--ids是传的，#&#123;id&#125;是遍历的--&gt;&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;Blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id=#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; test 12345678910111213141516171819@Testpublic void queryBlogForeach()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper blogMapper = sqlSession.getMapper(BlogMapper.class); Map map = new HashMap(); ArrayList&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(1); ids.add(3); map.put(&quot;ids&quot;,ids); List&lt;Blog&gt; list = blogMapper.queryBlogForeach(map); for (Blog blog : list) &#123; System.out.println(blog); &#125; sqlSession.close();&#125; 12. 缓存（了解）1. 一级缓存 开启日志 测试一个session中查询两次相同记录。 缓存失效： 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。 查询不同的mapper.xml 手动清除缓存 一级缓存默认开启，只在一次sqlseesion中有效 2. 二级缓存 开启全局缓存 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 在当前mapper.xml中使用二级缓存 1234&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; test 123456789101112131415@Testpublic void test()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); SqlSession sqlSession1 = MybatisUtils.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.queryUserByid(1); System.out.println(user); sqlSession.close(); UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class); User user1 = userMapper1.queryUserByid(1); System.out.println(user1); System.out.println(user==user1); sqlSession1.close();&#125; 只用cache时加序列化 1&lt;cache/&gt; 实体类 1234567891011121314151617package com.hou.pojo;import lombok.Data;import java.io.Serializable;@Datapublic class User implements Serializable &#123; private int id; private String name; private String pwd; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125;&#125; 小结： 只有开启了二级缓存，在Mapper下有效 所有数据都会先放在一级缓存 只有当回话提交，或者关闭的时候，才会提交到二级缓存 3. 自定义缓存-ehcache123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt; ehcache.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt; &lt;!-- diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录 user.dir – 用户当前工作目录 java.io.tmpdir – 默认临时文件路径 --&gt; &lt;diskStore path=&quot;java.io.tmpdir/Tmp_EhCache&quot;/&gt; &lt;!-- defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。 --&gt; &lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统当机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 --&gt; &lt;defaultCache eternal=&quot;false&quot; maxElementsInMemory=&quot;10000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;259200&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;cache name=&quot;cloud_user&quot; eternal=&quot;false&quot; maxElementsInMemory=&quot;5000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;1800&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;&lt;/ehcache&gt;"},{"path":"/2023/04/24/springMVC/","content":"SpringMVC1、回顾MVC1.1、什么是MVC MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）： 数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 1.2、Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； 1.3、Model2时代Model2把一个项目分成三部分，包括视图、控制、模型。 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析： Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 1.4、回顾Servlet 新建一个Maven工程当做父工程！pom依赖！ 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！ 导入servlet 和 jsp 的 jar 依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt; 编写一个Servlet类，用来处理用户的请求 123456789101112131415161718192021222324package nuc.ss.servlet;//实现Servlet接口public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //取得参数 String method = req.getParameter(&quot;method&quot;); if (method.equals(&quot;add&quot;))&#123; req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;); &#125; if (method.equals(&quot;delete&quot;))&#123; req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;); &#125; //业务逻辑 //视图跳转 req.getRequestDispatcher(&quot;/WEB-INF/jsp/hello.jsp&quot;).forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req,resp); &#125;&#125; 编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 在web.xml中注册Servlet 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/user&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置Tomcat，并启动测试 localhost:8080/user?method=add localhost:8080/user?method=delete MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： ​ 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等…. 2、什么是SpringMVC2.1、概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web 我们为什么要学习SpringMVC呢? Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . 最重要的一点还是用的人多 , 使用的公司多 . 2.2、中心控制器 Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。 SpringMVC的原理如下图所示： 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 原图 &lt;font color=red&gt;中文图&lt;/font&gt; ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200719143342368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDYzNTE5OA==,size_16,color_FFFFFF,t_70) 2.3、SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080 ——&gt; 服务器域名 SpringMVC ——&gt; 部署在服务器上的web站点 hello ——&gt; 表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 3、第一个MVC程序3.1、配置版 新建一个Moudle ， springmvc-02-hello ， 添加web的支持！ 确定导入了SpringMVC 的依赖！ 配置web.xml ， 注册DispatcherServlet 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 添加 处理映射器（可省略） 1&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; 添加 处理器适配器（可省略） 12&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; 添加 视图解析器 12345678&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； 1234567891011121314151617181920212223package nuc.ss.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//注意：这里我们先导入Controller接口public class HelloController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC!&quot;); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(&quot;hello&quot;); //: /WEB-INF/jsp/hello.jsp return mv; &#125;&#125; 将自己的类交给SpringIOC容器，注册bean 123&lt;!--Handler--&gt;&lt;bean id=&quot;/hello&quot; class=&quot;nuc.ss.controller.HelloController&quot;/&gt; 写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat 启动测试！ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ 重启Tomcat 即可解决！ 小结：我们来看个注解版实现，这才是SpringMVC的精髓。 3.2、注解版 新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 由于Maven可能存在资源过滤的问题，我们将配置完善 123456789101112131415161718192021&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 配置web.xml 注意点： 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; / 和 /* 的区别： &lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。 &lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=&quot;nuc.ss.controller&quot;/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 让IOC的注解生效 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ….. MVC的注解驱动 配置视图解析器 创建Controller 编写一个Java控制类：nuc.ss.controller.HelloController , 注意编码规范 1234567891011121314151617181920package nuc.ss.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/HelloController&quot;)public class HelloController &#123; //真实访问地址 : 项目名/HelloController/hello @RequestMapping(&quot;/hello&quot;) public String sayHello(Model model)&#123; //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); //web-inf/jsp/hello.jsp return &quot;hello&quot;; &#125;&#125; @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp 创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SpringMVC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat运行 配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！ OK，运行成功！ 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置 4、RestFul和控制器4.1、控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 4.2、实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； 123456//实现该接口的类获得控制器功能public interface Controller &#123; //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;&#125; 测试 新建一个Moudle，springmvc-04-controller！ mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 12345678910111213//定义控制器//注意点：不要导错包，实现Controller接口，重写方法；public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;Test1Controller&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 12&lt;bean name=&quot;/t1&quot; class=&quot;nuc.ss.controller.ControllerTest1&quot;/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 123&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;&lt;context:component-scan base-package=&quot;nuc.ss.controller&quot;/&gt; 增加一个ControllerTest2类，使用注解实现； 1234567891011121314//@Controller注解的类会自动添加到Spring上下文中@Controllerpublic class ControllerTest2&#123; //映射访问路径 @RequestMapping(&quot;/t2&quot;) public String index(Model model)&#123; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;); //返回视图位置 return &quot;test&quot;; &#125;&#125; 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图(test)，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！ RequestMapping@RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 12345678@Controllerpublic class TestController &#123; @RequestMapping(&quot;/h1&quot;) public String test()&#123; return &quot;test&quot;; &#125;&#125; 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 123456789@Controller@RequestMapping(&quot;/admin&quot;)public class TestController &#123; @RequestMapping(&quot;/h1&quot;) public String test()&#123; return &quot;test&quot;; &#125;&#125; 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； RestFul 风格概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get ​ http://127.0.0.1/item/queryItem.action?id=1 查询,GET ​ http://127.0.0.1/item/saveItem.action 新增,POST ​ http://127.0.0.1/item/updateItem.action 更新,POST ​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ ​ http://127.0.0.1/item/1 查询,GET ​ http://127.0.0.1/item 新增,POST ​ http://127.0.0.1/item 更新,PUT ​ http://127.0.0.1/item/1 删除,DELETE 学习测试 在新建一个类 RestFulController 12@Controllerpublic class RestFulController &#123;&#125; 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 12345678910111213141516@Controllerpublic class RestFulController &#123; //映射访问路径 @RequestMapping(&quot;/add/&#123;p1&#125;/&#123;p2&#125;&quot;) public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123; int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result); //返回视图位置 return &quot;test&quot;; &#125; &#125; 我们来测试请求查看下 思考：使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/add/1/a，则路径与方法不匹配，而不会是参数转换失败。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SXqT29c2-1595140755423)(SpringMVC课堂笔记.assets/1595129271494.png)] 我们来修改下对应的参数类型，再次测试 1234567891011//映射访问路径@RequestMapping(&quot;/add/&#123;p1&#125;/&#123;p2&#125;&quot;)public String index(@PathVariable int p1, @PathVariable String p2, Model model)&#123; String result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result); //返回视图位置 return &quot;test&quot;;&#125; 、 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 我们来测试一下： 增加一个方法 1234567//映射访问路径,必须是POST请求@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.POST&#125;)public String index2(Model model)&#123; model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;); return &quot;test&quot;;&#125; 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了； 1234567//映射访问路径,必须是Get请求@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.GET&#125;)public String index2(Model model)&#123; model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;); return &quot;test&quot;;&#125; 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个：组合注解 123456@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！ 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 扩展：小黄鸭调试法场景一：我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。 场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。 其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。 此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。 5、结果跳转方式5.1、ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} 123456789&lt;!-- 视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt; 对应的controller类 1234567891011public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; 5.2、ServletAPIServletAPI 通过设置ServletAPI , 不需要视图解析器 . 通过HttpServletResponse进行输出 通过HttpServletResponse实现重定向 通过HttpServletResponse实现转发 12345678910111213141516171819202122@Controllerpublic class ResultGo &#123; @RequestMapping(&quot;/result/t1&quot;) public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;); &#125; @RequestMapping(&quot;/result/t2&quot;) public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.sendRedirect(&quot;/index.jsp&quot;); &#125; @RequestMapping(&quot;/result/t3&quot;) public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123; //转发 req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;); req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp); &#125;&#125; 5.3、SpringMVC通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉 默认为forward转发（也可以加上） redirect转发需特别加 123456789101112131415161718192021@Controllerpublic class ResultSpringMVC &#123; @RequestMapping(&quot;/rsm/t1&quot;) public String test1()&#123; //转发 return &quot;/index.jsp&quot;; &#125; @RequestMapping(&quot;/rsm/t2&quot;) public String test2()&#123; //转发二 return &quot;forward:/index.jsp&quot;; &#125; @RequestMapping(&quot;/rsm/t3&quot;) public String test3()&#123; //重定向 return &quot;redirect:/index.jsp&quot;; &#125;&#125; 通过SpringMVC来实现转发和重定向 - 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . 默认为forward转发（不可以加上） redirect转发需特别加 1234567891011121314151617@Controllerpublic class ResultSpringMVC2 &#123; @RequestMapping(&quot;/rsm2/t1&quot;) public String test1()&#123; //转发 return &quot;test&quot;; &#125; @RequestMapping(&quot;/rsm2/t2&quot;) public String test2()&#123; //重定向 return &quot;redirect:/index.jsp&quot;; //return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/ &#125;&#125; 6、数据处理6.1、处理提交数据1、提交的域名称和处理方法的参数名一致 提交数据 : http://localhost:8080/hello?name=kuangshen 处理方法 : 123456@RequestMapping(&quot;/hello&quot;)public String hello(String name)&#123; System.out.println(name); return &quot;hello&quot;;&#125; 后台输出 : kuangshen 2、提交的域名称和处理方法的参数名不一致 提交数据 : http://localhost:8080/hello?username=kuangshen 处理方法 : 1234567//@RequestParam(&quot;username&quot;) : username提交的域的名称 .@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name)&#123; System.out.println(name); return &quot;hello&quot;;&#125; 后台输出 : kuangshen 3、提交的是一个对象 要求提交的表单域和对象的属性名一致 , 参数使用对象即可 实体类 123456789public class User &#123; private int id; private String name; private int age; //构造 //get/set //tostring()&#125; 提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15 处理方法 : 123456@RequestMapping(&quot;/user&quot;)public String user(User user)&#123; System.out.println(user); return &quot;hello&quot;;&#125; 后台输出 : User { id=1, name=’kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 6.2、数据显示到前端第一种 : 通过ModelAndView 我们前面一直都是如此 . 就不过多解释 1234567891011public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; 第二种 : 通过ModelMap ModelMap 12345678910@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap modelMap)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); modelMap.addAttribute(&quot;name&quot;,name); System.out.println(name); return &quot;hello&quot;;&#125; 第三种 : 通过Model Model 123456789@RequestMapping(&quot;/ct2/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;msg&quot;,name); System.out.println(name); return &quot;test&quot;;&#125; 6.3、对比就对于新手而言简单来说使用区别就是： 1234Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 7、乱码问题测试步骤： 我们可以在首页编写一个提交的表单 12345&lt;form action=&quot;/e/t&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 后台编写对应的处理类 123456789@Controllerpublic class Encoding &#123; @RequestMapping(&quot;/e/t&quot;) public String test(Model model,String name)&#123; model.addAttribute(&quot;msg&quot;,name); //获取表单提交的值 return &quot;test&quot;; //跳转到test页面显示输入的值 &#125;&#125; 输入中文测试，发现乱码 不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！ 以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 . 修改了xml文件需要重启服务器！ 12345678910111213filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注意：这里写/*，写/的话过滤不了jsp页面，不能解决乱码 但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 . 处理方法 : 修改tomcat配置文件 ：设置编码！ 1234&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 自定义过滤器（万能解决） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.kuang.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;/*** 解决get和post请求 全部乱码的过滤器*/public class GenericEncodingFilter implements Filter &#123; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125;&#125;//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper &#123; private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) &#123; super(request);// super必须写 this.request = request; &#125; // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() &#123; // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(&quot;post&quot;)) &#123; // post请求 try &#123; // 处理post乱码 request.setCharacterEncoding(&quot;utf-8&quot;); return request.getParameterMap(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123; // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) &#123; String[] values = parameterMap.get(parameterName); if (values != null) &#123; for (int i = 0; i &lt; values.length; i++) &#123; try &#123; // 处理get乱码 values[i] = new String(values[i] .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; hasEncode = true; &#125; return parameterMap; &#125; return super.getParameterMap(); &#125; //取一个值 @Override public String getParameter(String name) &#123; Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) &#123; return null; &#125; return values[0]; // 取回参数的第一个值 &#125; //取所有值 @Override public String[] getParameterValues(String name) &#123; Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; &#125;&#125; 一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！ 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！ 8、Json交互处理8.1、什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： 1234&#123;&quot;name&quot;: &quot;QinJiang&quot;&#125;&#123;&quot;age&quot;: &quot;3&quot;&#125;&#123;&quot;sex&quot;: &quot;男&quot;&#125; 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 123var obj = &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;; //这是一个 JSON 字符串，本质是一个字符串 8.2、JSON 和 JavaScript 对象互转要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 123var obj = JSON.parse(&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;);//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125; 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： 123var json = JSON.stringify(&#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;);//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27; 代码测试 新建一个module ，springmvc-05-json ， 添加web的支持 在web目录下新建一个 json-1.html ， 编写测试内容 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JSON_秦疆&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //编写一个js的对象 var user = &#123; name:&quot;秦疆&quot;, age:3, sex:&quot;男&quot; &#125;; //将js对象转换成json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转换为js对象 var user2 = JSON.parse(str); console.log(user2.age,user2.name,user2.sex);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在IDEA中使用浏览器打开，查看控制台输出！ 8.3、Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； 1234567&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 配置SpringMVC需要的配置 （web.xml） 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; springmvc-servlet.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； 123456789@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private int id; private String name; private int age;&#125; 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； 12345678910111213141516@Controllerpublic class UserController &#123;@RequestMapping(&quot;/j1&quot;) @ResponseBody//他就不会走视图解析器，会直接返回一个 字符串 public String json1() throws JsonProcessingException &#123; //jackson,ObjectMapper ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(1, &quot;秦疆一号&quot;, 12); //System.out.println(user); String str = mapper.writeValueAsString(user); return str; &#125; 此时输入中文会产生乱码 123//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;) 配置Tomcat ， 启动测试一下！http://localhost:8080/json1 【注意：使用json记得处理乱码问题】 8.4代码优化乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ 123456789101112131415&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 返回json字符串统一解决 @ResponseBody解决（每个方法都得加，不建议使用） 1234567891011121314151617@Controllerpublic class UserController &#123; //produces:指定响应体返回类型和编码 @RequestMapping(value = &quot;/json1&quot;) @ResponseBody public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(1, &quot;秦疆一号&quot;, 12); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; @RestController（直接加到类上即可） 123456789101112131415@RestControllerpublic class UserController &#123; @RequestMapping(value = &quot;/j1&quot;) public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(1, &quot;秦疆一号&quot;, 12); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); return str; &#125;&#125; 8.5、测试集合输出增加一个新的方法 12345678910111213141516171819202122@RequestMapping(&quot;/j2&quot;)public String json2() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(1, &quot;秦疆1号&quot;, 12); User user2 = new User(2, &quot;秦疆2号&quot;, 12); User user3 = new User(3, &quot;秦疆3号&quot;, 12); User user4 = new User(4, &quot;秦疆4号&quot;, 12); User user5 = new User(5, &quot;秦疆5号&quot;, 12); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); list.add(user5); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str;&#125; 运行结果 : 十分完美，没有任何问题！ 8.6、输出时间对象 增加一个新的方法 123456789101112@RequestMapping(&quot;/j3&quot;)public String json3() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str;&#125; 运行结果 : 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 123456789101112131415161718@RequestMapping(&quot;/j3&quot;)public String json4() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str;&#125; 运行结果 : 成功的输出了时间！ 抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 123456789101112131415161718192021222324252627public class JsonUtils &#123; public static String getJson(Object object) &#123; return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125; public static String getJson(Object object, String dateFormat) &#123; ObjectMapper mapper = new ObjectMapper(); //java自定义日期格式 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //sdf.format(date) // 使用ObjectMapper 来格式化输出 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false); mapper.setDateFormat(sdf); try &#123; //ObjectMapper,时间解析后的默认格式为：TImestamp.时间戳 return mapper.writeValueAsString(object); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 我们使用工具类，代码就更加简洁了！ 123456789@RequestMapping(&quot;/j3&quot;) public String json3()&#123; Date date = new Date(); return JsonUtils.getJson(date,&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125;&#125; 大功告成！完美！ 8.7、FastJson fastjson.jar是阿里开发的一款专门用于Java开发的包， 实现json对象与JavaBean对象的转换， 实现JavaBean对象与json字符串的转换， 实现json对象与json字符串的转换。 实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ 123456&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt; fastjson 三个主要的类： JSONObject 代表 json 对象 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组 内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 1234567891011121314151617181920212223242526272829303132333435363738@RequestMapping(&quot;/j4&quot;) //@ResponseBody//他就不会走视图解析器，会直接返回一个 字符串 public String json4()&#123; User user1 = new User(1, &quot;秦疆1号&quot;, 12); User user2 = new User(2, &quot;秦疆2号&quot;, 12); User user3 = new User(3, &quot;秦疆3号&quot;, 12); User user4 = new User(4, &quot;秦疆4号&quot;, 12); User user5 = new User(5, &quot;秦疆5号&quot;, 12); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); list.add(user5); System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;); String str1 = JSON.toJSONString(list); System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1); String str2 = JSON.toJSONString(user1); System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2); System.out.println(&quot; ****** JSON字符串 转 Java对象*******&quot;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1); System.out.println(&quot; ****** Java对象 转 JSON对象 ******&quot;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;)); System.out.println(&quot; ****** JSON对象 转 Java对象 ******&quot;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user); return JSON.toJSONString(list); &#125; 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！ 9、Ajax研究9.1、简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 9.2、伪造Ajax我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 新建一个module ：sspringmvc-06-ajax ， 导入web支持！ 编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var myDate = new Date(); document.getElementById(&#x27;currentTime&#x27;).innerText = myDate.getTime(); &#125;; function LoadPage()&#123; var targetUrl = document.getElementById(&#x27;url&#x27;).value; console.log(targetUrl); document.getElementById(&quot;iframePosition&quot;).src = targetUrl; &#125;&lt;/script&gt;&lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=&quot;currentTime&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=&quot;url&quot; type=&quot;text&quot; value=&quot;https://www.baidu.com/&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;LoadPage()&quot;&gt; &lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 500px;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 ….等等 9.3、jQuery.ajax 纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ 12345678910111213141516171819202122jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 &quot;xml&quot;: 将服务器端返回的内容转换成xml格式 &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式 &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象 &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 配置web.xml 和 springmvc的配置文件【记得静态资源过滤和注解驱动配置上】 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!--静态资源过滤--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--注解驱动配--&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 编写一个AjaxController 1234567891011121314@Controllerpublic class AjaxController &#123; @RequestMapping(&quot;/a1&quot;) public void ajax1(String name , HttpServletResponse response) throws IOException &#123; if (&quot;admin&quot;.equals(name))&#123; response.getWriter().print(&quot;true&quot;); &#125;else&#123; response.getWriter().print(&quot;false&quot;); &#125; &#125;&#125; 导入jquery ， 可以使用在线的CDN ， 也可以下载导入 123&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; 编写index.jsp测试 123456789101112131415161718192021222324252627&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;--%&gt; &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;, data:&#123;&#x27;name&#x27;:$(&quot;#txtName&quot;).val()&#125;, success:function (data,status) &#123; alert(data); alert(status); &#125; &#125;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;%--onblur：失去焦点触发事件--%&gt;用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; onblur=&quot;a1()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ 9.4、Springmvc实现 实体类user（使用了lombok插件，可以自己写实现类方法） 1234567891011@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private String name; private int age; private String sex;&#125; 我们来获取一个集合对象，展示到前端页面 123456789@RequestMapping(&quot;/a2&quot;)public List&lt;User&gt; ajax2()&#123; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(&quot;秦疆1号&quot;,3,&quot;男&quot;)); list.add(new User(&quot;秦疆2号&quot;,3,&quot;男&quot;)); list.add(new User(&quot;秦疆3号&quot;,3,&quot;男&quot;)); return list; //由于@RestController注解，将list转成json格式返回&#125; 前端页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/static/js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&quot;#btn&quot;).click(function () &#123; // console.log(&#x27;点击事件成功&#x27;) // $.post(url,param,[可以省略],success) $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123; console.log(data[0].name); let html = &quot;&quot;; for (let i = 0; i &lt; data.length; i++) &#123; html += `&lt;tr&gt; &lt;td&gt;$&#123;&quot;$&#123;data[i].name&#125;&quot;&#125;&lt;/td&gt; &lt;td&gt;$&#123;&quot;$&#123;data[i].age&#125;&quot;&#125;&lt;/td&gt; &lt;td&gt;$&#123;&quot;$&#123;data[i].sex&#125;&quot;&#125;&lt;/td&gt; &lt;/tr&gt;` &#125; $(&quot;#content&quot;).html(html) console.log(html) &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;加载数据&quot; id=&quot;btn&quot;&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;content&quot;&gt; &lt;%--数据：后台--%&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 成功实现了数据回显！可以体会一下Ajax的好处！ 9.5、注册提示效果 我们写一个Controller 123456789101112131415161718192021@RequestMapping(&quot;/a3&quot;)public String ajax3(String name,String pwd)&#123; String msg = &quot;&quot;; //模拟数据库中存在数据 if (name!=null)&#123; if (&quot;admin&quot;.equals(name))&#123; msg = &quot;OK&quot;; &#125;else &#123; msg = &quot;用户名输入错误&quot;; &#125; &#125; if (pwd!=null)&#123; if (&quot;123456&quot;.equals(pwd))&#123; msg = &quot;OK&quot;; &#125;else &#123; msg = &quot;密码输入有误&quot;; &#125; &#125; return msg; //由于@RestController注解，将msg转成json格式返回&#125; 前端页面 login.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;, data:&#123;&#x27;name&#x27;:$(&quot;#name&quot;).val()&#125;, success:function (data) &#123; if (data.toString()==&#x27;OK&#x27;)&#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#userInfo&quot;).html(data); &#125; &#125;); &#125; function a2()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;, data:&#123;&#x27;pwd&#x27;:$(&quot;#pwd&quot;).val()&#125;, success:function (data) &#123; if (data.toString()==&#x27;OK&#x27;)&#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#pwdInfo&quot;).html(data); &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; 用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt; &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; 密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt; &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 记得处理json乱码问题 1234567891011121314151617&lt;!--JSON乱码问题配置--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 测试一下效果，动态请求响应，局部刷新，就是如此！ 9.6、获取baidu接口Demo JSONP.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;JSONP百度搜索&lt;/title&gt; &lt;style&gt; #q&#123; width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; &#125; #ul&#123; width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; &#125; #ul li&#123; line-height: 30px; padding: 0 10px; &#125; #ul li:hover&#123; background-color: #f60; color: #fff; &#125; &lt;/style&gt; &lt;script&gt; // 2.步骤二 // 定义demo函数 (分析接口、数据) function demo(data)&#123; var Ul = document.getElementById(&#x27;ul&#x27;); var html = &#x27;&#x27;; // 如果搜索数据存在 把内容添加进去 if (data.s.length) &#123; // 隐藏掉的ul显示出来 Ul.style.display = &#x27;block&#x27;; // 搜索到的数据循环追加到li里 for(var i = 0;i&lt;data.s.length;i++)&#123; html += &#x27;&lt;li&gt;&#x27;+data.s[i]+&#x27;&lt;/li&gt;&#x27;; &#125; // 循环的li写入ul Ul.innerHTML = html; &#125; &#125; // 1.步骤一 window.onload = function()&#123; // 获取输入框和ul var Q = document.getElementById(&#x27;q&#x27;); var Ul = document.getElementById(&#x27;ul&#x27;); // 事件鼠标抬起时候 Q.onkeyup = function()&#123; // 如果输入框不等于空 if (this.value != &#x27;&#x27;) &#123; // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ // 创建标签 var script = document.createElement(&#x27;script&#x27;); //给定要跨域的地址 赋值给src //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址 script.src = &#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#x27;+this.value+&#x27;&amp;cb=demo&#x27;; // 将组合好的带src的script标签追加到body里 document.body.appendChild(script); &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;q&quot; /&gt;&lt;ul id=&quot;ul&quot;&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 测试 10、拦截器10.1、概述 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。 开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别：拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何javaweb工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 10.2、自定义拦截器 新建一个Moudule ， springmvc-Interceptor ， 添加web支持 配置web.xml 和 springmvc-servlet.xml 文件 编写一个拦截器（必须实现 HandlerInterceptor 接口） 12345678910111213141516171819202122232425262728package nuc.ss.config;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123; //return true; 执行下一个拦截器，放行 //return false; 不执行下一个拦截器，拦截 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;===========处理前===========&quot;); return true; &#125; //日志 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;===========处理后===========&quot;); &#125; //日志 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;===========清理===========&quot;); &#125;&#125; 在springmvc的配置文件中配置拦截器 12345678910&lt;!--拦截器配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--包括这个请求下面的所有请求--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;nuc.ss.config.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 编写一个Controller，接收请求 1234567891011121314package nuc.ss.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class TestController &#123; @GetMapping(&quot;/t1&quot;) public String test() &#123; System.out.println(&quot;TestController.test&quot;); return &quot;ok&quot;; &#125;&#125; 启动tomcat 测试一下！(http://localhost:8888/t1) 10.3、验证用户是否登录 (认证用户)实现思路 有一个登陆页面，需要写一个controller访问页面。 登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。 拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面 测试： 编写一个登陆页面 login.jsp 123456789101112131415161718&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--在web-inf下面的所有页面或者资源，只能通过controller或者Servlet进行访问--%&gt;&lt;h1&gt;登录页面&lt;/h1&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 编写一个Controller处理请求 123456789101112131415161718192021222324252627282930@Controller@RequestMapping(&quot;/user&quot;)public class LoginController &#123; @RequestMapping(&quot;/main&quot;) public String main() &#123; return &quot;main&quot;; &#125; @RequestMapping(&quot;/goLogin&quot;) public String login() &#123; return &quot;login&quot;; &#125; @RequestMapping(&quot;/login&quot;) public String login(HttpSession session, String username, String password, Model model) &#123; //把用户的信息存在session中 session.setAttribute(&quot;userLoginInfo&quot;,username); model.addAttribute(&quot;password&quot;,password); model.addAttribute(&quot;username&quot;,username); return &quot;main&quot;; &#125; @RequestMapping(&quot;/goOut&quot;) public String goOut(HttpSession sessionl) &#123; sessionl.removeAttribute(&quot;userLoginInfo&quot;); return &quot;login&quot;; &#125;&#125; 编写一个登陆成功的页面 main.jsp 123456789101112131415161718&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;span&gt;$&#123;password&#125;&lt;/span&gt;&lt;span&gt;$&#123;username&#125;&lt;/span&gt;&lt;p&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/goOut&quot;&gt;注销&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！ 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/goLogin&quot;&gt;登录页面&lt;/a&gt;&lt;/h1&gt;&lt;h1&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/main&quot;&gt;首页&lt;/a&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 编写用户登录拦截器 123456789101112131415161718192021222324252627282930package nuc.ss.config;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HttpSession session = request.getSession(); //放行:判断什么情况下登录 //登录页面也会放行 if (request.getRequestURI().contains(&quot;goLogin&quot;)) &#123; return true; &#125; if (request.getRequestURI().contains(&quot;login&quot;)) &#123; return true; &#125; if (session.getAttribute(&quot;userLoginInfo&quot;) != null) &#123; return true; &#125; //判断什么情况下没有登录 request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request,response); return false; &#125;&#125; 在Springmvc的配置文件中注册拦截器 12345678&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean id=&quot;loginInterceptor&quot; class=&quot;com.kuang.interceptor.LoginInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 再次重启Tomcat测试！ OK，测试登录拦截功能无误. 11、文件上传和下载11.1、准备工作 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传。 SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。 前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器； 对表单中的 enctype 属性做个详细的说明： application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。 12345&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。 Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。 而Spring MVC则提供了更简单的封装。 Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。 Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类： CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。 11.2、文件上传 导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包； 12345678910111213&lt;!--文件上传--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--servlet-api导入高版本的--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt; 配置bean：multipartResolver 【注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！】 123456789&lt;!--文件上传配置--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;&lt;/bean&gt; CommonsMultipartFile 的 常用方法： String getOriginalFilename()：获取上传文件的原名 InputStream getInputStream()：获取文件流 void transferTo(File dest)：将上传文件保存到一个目录文件中 我们去实际测试一下 编写前端页面 12345&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;&lt;/form&gt; Controller 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package nuc.ss.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.commons.CommonsMultipartFile;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.net.URLEncoder;@RestControllerpublic class FileController &#123; //@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象 //批量上传CommonsMultipartFile则为数组即可 @RequestMapping(&quot;/upload&quot;) public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123; //获取文件名 : file.getOriginalFilename(); String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！ if (&quot;&quot;.equals(uploadFileName))&#123; return &quot;redirect:/index.jsp&quot;; &#125; System.out.println(&quot;上传文件名 : &quot;+uploadFileName); //上传路径保存设置 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); //如果路径不存在，创建一个 File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; System.out.println(&quot;上传文件保存地址：&quot;+realPath); InputStream is = file.getInputStream(); //文件输入流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流 //读取写出 int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1)&#123; os.write(buffer,0,len); os.flush(); &#125; os.close(); is.close(); return &quot;redirect:/index.jsp&quot;; &#125; /* * 采用file.Transto 来保存上传的文件 */ @RequestMapping(&quot;/upload2&quot;) public String fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123; //上传路径保存设置 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; //上传文件地址 System.out.println(&quot;上传文件保存地址：&quot;+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename())); return &quot;redirect:/index.jsp&quot;; &#125; @RequestMapping(value=&quot;/download&quot;) public String downloads(HttpServletResponse response , HttpServletRequest request) throws Exception&#123; //要下载的图片地址 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); String fileName = &quot;bg1.jpg&quot;; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码 response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据 //设置响应头 response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot;+ URLEncoder.encode(fileName, &quot;UTF-8&quot;)); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1)&#123; out.write(buff, 0, index); out.flush(); &#125; out.close(); input.close(); return null; &#125;&#125; 测试上传文件，OK！ 采用file.Transto 来保存上传的文件 编写Controller 123456789101112131415161718192021/** 采用file.Transto 来保存上传的文件*/@RequestMapping(&quot;/upload2&quot;)public String fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123; //上传路径保存设置 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; //上传文件地址 System.out.println(&quot;上传文件保存地址：&quot;+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename())); return &quot;redirect:/index.jsp&quot;;&#125; 前端表单提交地址修改 访问提交测试，OK！ 11.3、文件下载文件下载步骤： 设置 response 响应头 读取文件 – InputStream 写出文件 – OutputStream 执行操作 关闭流 （先开后关） 代码实现： 1234567891011121314151617181920212223242526272829303132@RequestMapping(value=&quot;/download&quot;)public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception&#123; //要下载的图片地址 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); String fileName = &quot;基础语法.jpg&quot;; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码 response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据 //设置响应头 response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;)); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1)&#123; out.write(buff, 0, index); out.flush(); &#125; out.close(); input.close(); return null;&#125; 前端 12&lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt; 测试，文件下载OK"},{"title":"Hello World","path":"/2023/04/24/hello-world/","content":"Welcome to 阿云同学! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]